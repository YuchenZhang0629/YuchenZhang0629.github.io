from __future__ import annotations

from abc import abstractmethod
from operator import ne
from re import I
from tracemalloc import start
from typing import Iterable
import itertools
from hashtable import BLANK, KT, VT, HashTable


class OpenAddressingHashTable(HashTable):
    """Abstract base class for hashtables which use open addressing to resolve collisions."""

    def items(self) -> Iterable[tuple[KT, VT]]:
        for bucket in self._buckets:
            if bucket is BLANK:
                continue
            yield bucket

    def __setitem__(self, input_key: KT, input_value: VT):
        index = hash(input_key) % self._capacity
        buckets = self._buckets

        if buckets[index] is not BLANK:
            index_sequence = iter(self._generate_indices(start_index=index))
            while buckets[index] is not BLANK and buckets[index][0] != input_key:
                index = next(index_sequence)

        if buckets[index] is BLANK:
            self._num_elements += 1

            # TODO: Encountered collision, probe until we find a blank slot or matching key (updating index)
            
        self._buckets[index] = (input_key, input_value)

        if self._load_factor > self._maximum_load_factor:
            # Maximum load factor exceeded, increase size of table
            self._resize()

    def __getitem__(self, search_key: KT) -> VT:
        index = hash(search_key) % self._capacity
        index_sequence = iter(self._generate_indices(start_index=index))
        """
        buckets = self._buckets
        index_sequence = iter(self._generate_indices(start_index=index))
        while buckets[index][0] != search_key:
            index = next(index_sequence)
            if self._buckets[index][0] == search_key:
                return self._buckets[index][1]
        """
        while self._buckets[index] is not BLANK and self._buckets[index][0] != search_key:
            index = next(index_sequence)
        if self._buckets[index] is not BLANK and self._buckets[index][0] == search_key:
            return self._buckets[index][1]
        raise KeyError("Search key is not present.")

        # TODO: Loop through the indices to find the value matching the search key
        # Raise KeyError if the search key is not present
        ...

    @abstractmethod
    def _generate_indices(self, start_index: int) -> Iterable[int]:
        """Generates a sequence of indices using some form of open addressing.

        Parameters
        ----------
        start_index : int
            First index in sequence.

        Yields
        ------
        indices : Iterable[int]
            Sequence of indices generated by the open addressing strategy.
        """
        return QuadraticProbingHashTable._generate_indices(start_index)
        ...


class LinearProbingHashTable(OpenAddressingHashTable):
    """OpenAddressingHashTable implementation using linear probing."""

    def _generate_indices(self, start_index: int) -> Iterable[int]:
        i = 0
        while True:
            x = (start_index + i) % self._capacity
            yield x
            i += 1

        # TODO: Yield a sequence of indices using linear probing, starting with start_index
        ...


class QuadraticProbingHashTable(OpenAddressingHashTable):
    """OpenAddressingHashTable implementation using quadratic probing."""

    def _generate_indices(self, start_index: int) -> Iterable[int]:
        i = 0
        while True:
            x = int((start_index + (i**2+i)/2)) % self._capacity
            yield x
            i += 1

        # TODO: Yield a sequence of indices using linear probing, starting with start_index
        ...
